#!/usr/bin/python3#    Data analysis tools for X-ray diffraction data obtained at#    the KMC-3 XPP endstation of BESSY II.#    Copyright (C) 2022 Matthias Roessle and Florin Boariu.##    This program is free software: you can redistribute it and/or modify#    it under the terms of the GNU General Public License as published by#    the Free Software Foundation, either version 3 of the License, or#    (at your option) any later version.##    This program is distributed in the hope that it will be useful,#    but WITHOUT ANY WARRANTY; without even the implied warranty of#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the#    GNU General Public License for more details.##    You should have received a copy of the GNU General Public License#    along with this program.  If not, see <http://www.gnu.org/licenses/>.import os, reimport xrayutilities as xuimport h5pyimport tqdm        class XPP(object):    '''        '''        def __init__(self, specName):        '''        '''        specFile               = self.specName + '.spec'        specFileH5             = self.specName + '.h5'        # convert the specified spec file into a parsable and more importantly iterable HDF5 file        if os.path.isfile(specFileH5):            # check if .h5 file already exists            specFileOrig       = xu.io.SPECFile(specFile)            specFileOrig.Update()            specFileOrig.Save2HDF5(specFileH5)        else:            # otherwise generate .h5 file from spec file            specFileOrig       = xu.io.SPECFile(specFile)            specFileOrig.Save2HDF5(specFileH5)                    def detectorCalib(self, deltas):            '''            '''                    def doQtransform(self, deltas):            '''            '''                                def readH5(h5File, scanNr, tauOffset = 300.4):            '''Read an h5 file after converting the measured Pilatus images into a q_x -- q_z grid.                args                h5File          name of the h5 file to load                scanNr          number of the scan to extract from the file                tauOffset       offset value of tau_APD                returns                dictionary with q_x, q_y, q_z, delay, temperature, grid of q vectors, and measured intensity            '''            h5File             = h5File            h5Data             = h5py.File(h5File, 'r')            # get key (aka spec filename) of the HDF5 file            specNameKey        = list(h5Data.keys())[0]            FileNameQx         = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/IntQx'            FileNameQy         = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/IntQy'            FileNameQz         = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/IntQz'            FileNameGrid       = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/grid'            FileNameIntensity  = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/QMapData'            FileNameQx_X       = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/qx'            FileNameQx_Y       = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/qy'            FileNameQx_Z       = specNameKey + '/scan_' + str(scanNr) + '/ReducedData/qz'            SpecData           = specNameKey + '/scan_' + str(scanNr) + '/data'            qx_X               = h5Data[FileNameQx_X]            qy_X               = h5Data[FileNameQx_Y]            qz_X               = h5Data[FileNameQx_Z]            qx                 = h5Data[FileNameQx]            qy                 = h5Data[FileNameQy]            qz                 = h5Data[FileNameQz]            Intensity          = h5Data[FileNameIntensity]            grid               = h5Data[FileNameGrid]            Temp               = np.mean(h5Data[SpecData]['ls_t1'][0])            tauOffset          = tauOffset            delayMeas          = -np.mean(h5Data[SpecData]['PH_average'][1:]) + tauOffset # measured delay value corrected for tau_apd_0            delaySet           = 2 #h5Data[SpecData]['delay'][1]  # set delay            xQzVec             = qz_X            yQzVec             = qz            xQyVec             = qy_X            yQyVec             = qy            xQxVec             = qx_X            yQxVec             = qx            return {'xQx':xQxVec, 'yQx':yQxVec,                     'xQy':xQyVec, 'yQy':yQyVec,                     'xQz':xQzVec, 'yQz':yQzVec,                     'delayMeas':delayMeas,                     'delaySet':delaySet,                     'Temperature':Temp,                     'qGrid':grid,                     'Intensity':Intensity}### def plotQMap(h5File, scanNr, form = 'pcolormesh', colormap = 'viridis', zScale = 'auto'):#     '''Plot a q_x - q_z map#     args#         h5File          h5 file where the data are stored#         scanNr          number of the SPEC scan to plot#         form            'pcolormesh' and 'imshow' can be selected, standard is 'pcolormesh'#         colormap        must be a valid colormap for matplotlib, standard is 'viridis'#         zScale          'auto' determines the scale from the input data, alternatively an tuple [min, max] can be given#     returns#         a plot with the desired properities#     '''#     from pylab import cm#     from matplotlib.colors import LogNorm##     data = getQData(h5File, scanNr)##     if form == 'imshow':#         x = np.array(data['xQz'])#         y = np.array(data['xQx'])##         I = np.sum(np.asarray(data['Intensity'][:,:]),1)#         X,Y = np.meshgrid(x,y)##         if zScale == 'auto':#             vmin = I[I > 0].min()#             vmax = I.max()#         else:#             vmin = zScale[0]#             vmax = zScale[1]##         plt.figure('RSM scan #{}'.format(scanNr))#         plt.imshow(I, cmap = cm.viridis, norm = LogNorm(vmin = vmin, vmax = vmax), interpolation = 'bicubic', origin = 'lower', extent = (min(x), max(x), min(y), max(y)))#         cbar = plt.colorbar()#         cbar.set_label(r'I (a.u)', rotation = 270, fontsize = 14)#         plt.xlabel(r'$\mathrm{q_z \,\,(1/\AA)}$', fontsize = 14)#         plt.ylabel(r'$\mathrm{q_x \,\,(1/\AA)}$', fontsize = 14)#         plt.axis('tight')#         plt.show()##     if form == 'pcolormesh':#         x = np.array(data['xQz'])#         y = np.array(data['xQx'])##         I = np.sum(np.asarray(data['Intensity'][:,:]),1)#         X,Y = np.meshgrid(x,y)##         if zScale == 'auto':#             vmin = I[I > 0].min()#             vmax = I.max()#         else:#             vmin = zScale[0]#             vmax = zScale[1]##         plt.figure('RSM scan #{}'.format(scanNr))#         plt.pcolormesh(X, Y, I, shading = 'nearest', cmap = cm.viridis, norm = LogNorm(vmin = vmin, vmax = vmax))#         cbar = plt.colorbar()#         cbar.set_label(r'I (a. u.)', rotation = 270, fontsize = 14)#         plt.xlabel(r'$\mathrm{q_z \,\,(1/\AA)}$', fontsize = 14)#         plt.ylabel(r'$\mathrm{q_x \,\,(1/\AA)}$', fontsize = 14)#         plt.axis('tight')#         plt.xlim(min(x), max(x))#         plt.ylim(min(y), max(y))#         plt.show()### def plotOm2Th(scan, PilatusFolder = 'Pilatus', log = 'log', plotQz = True, plotQx = False, zScale = 'auto'):#     '''Plot omega - 2theta map of the measured area detector scan#     '''#     import glob, os, re#     import fabio#     import numpy as np#     import matplotlib.pyplot as plt#     from pylab import cm#     from matplotlib.colors import LogNorm##     images = glob.glob(PilatusFolder + str('/S%0*d' % (5, scan)) + '/*.tif')##     files = np.zeros(len(images))#     for idx, entry in enumerate(images):#         fileName = os.path.basename(entry)#         fileString = os.path.splitext(fileName)[0]#         fileNumber = re.findall('\d{1,}$', fileString)[0]#         files[idx] = fileNumber#     filesIdx = np.argsort(files)#     files = np.array(images)#     files = np.array(files)#     imagesSorted = files[filesIdx]#     print(imagesSorted)##     mapData = []#     for entry in imagesSorted:#         image = fabio.open(entry)#         data = image.data#         mapData.append(np.sum(data, axis = 1))#     mapData = np.array(mapData)##     if zScale == 'auto':#         vmin = mapData[mapData > 0].min()#         vmax = mapData.max()#     else:#         vmin = zScale[0]#         vmax = zScale[1]##     plt.figure()#     if log == 'log':#         plt.imshow(mapData.T, norm = LogNorm(vmin = vmin, vmax = vmax))#     else:#         plt.imshow(mapData.T)#     plt.xlabel('2$\Theta$', fontsize = 14)#     plt.ylabel('')#     cbar = plt.colorbar()#     cbar.set_label(r'I (a.u)', rotation = 270, fontsize = 14)#     plt.show()##     if plotQz == True:#         plt.figure()#         if log == 'log':#             plt.semilogy(np.sum(mapData.T, axis = 0))#         else:#             plt.plot(np.sum(mapData.T, axis = 0))#         plt.xlabel(r'$q_z$ ($\AA^{-1}$)', fontsize = 14)#         plt.ylabel(r'Intensity (a.u.)', fontsize = 14)#         plt.show()##     if plotQx == True:#         plt.figure()#         plt.semilogy(np.sum(mapData.T, axis = 1))#         plt.xlabel(r'$q_x$ ($\AA^{-1}$)', fontsize = 14)#         plt.show()## def plotMesh(h5File, scanNr, xMotor = 'TwoTheta', xPoints = 81, yMotor = 'Theta', yPoints = 401, zValues = 'Detector', colormap = 'viridis', zScale = 'auto', log = True):#     '''Plot a q_x - q_z map#     args#         h5File              h5 file where the data are stored#         scanNr              number of the SPEC scan to plot#         xMotor, yMotor      Counter to plot on the x resp. y axis#         xPoints, yPoints    number of points along the x resp. y axis#         zValues             Counter to plot on the z axis (aka intensity)#         colormap            must be a valid colormap for matplotlib, standard is 'viridis'#         zScale              'auto' determines the scale from the input data, alternatively an tuple [min, max] can be given#     returns#         an imshow plot of the mesh scan#     '''#     from pylab import cm#     from matplotlib.colors import LogNorm##     data = xu.io.geth5_scan(h5File, [scanNr])##     y = data[yMotor]#     x = data[xMotor]##     I = data[zValues].reshape(xPoints, yPoints)#     X,Y = np.meshgrid(x,y)##     if zScale == 'auto':#         vmin = I[I > 0].min()#         vmax = I.max()#     else:#         vmin = zScale[0]#         vmax = zScale[1]##     plt.figure('scan #{}'.format(scanNr))#     if log == True:#         plt.imshow(I, cmap = cm.viridis, norm = LogNorm(vmin = vmin, vmax = vmax), interpolation = 'bicubic', origin = 'lower', extent = (min(x), max(x), min(y), max(y)))#     elif log == False:#         plt.imshow(I, cmap = cm.viridis, interpolation = 'bicubic', origin = 'lower', extent = (min(x), max(x), min(y), max(y)))#     cbar = plt.colorbar()#     cbar.set_label(r'I (a.u)', rotation = 270, fontsize = 14)#     plt.xlabel(r'$2\theta \,\,(^{\circ})}$', fontsize = 14)#     plt.ylabel(r'$\omega \,\,(^{\circ})}$', fontsize = 14)#     plt.axis('tight')#     plt.show()### def plotRocking(h5File, scans, colormap = 'viridis', zScale = 'log'):#     '''Plot a q_x - q_z map#     args#         h5File          h5 file where the data are stored#         scanNr          number of the SPEC scan to plot#         form            'pcolormesh' and 'imshow' can be selected, standard is 'pcolormesh'#         colormap        must be a valid colormap for matplotlib, standard is 'viridis'#         zScale          'auto' determines the scale from the input data, alternatively an tuple [min, max] can be given#     returns#         a plot with the desired properities#     '''#     from pylab import cm#     from matplotlib.colors import LogNorm##     if zScale == 'lin':#         plt.figure('scan #{} linear'.format(scans))#         for s in scans:#             data = getQData(h5File, s)#             x = np.array(data['xQz'])#             y = np.array(data['yQz'])#             plt.plot(x, y, label = str(s))#         plt.xlabel(r'$\mathrm{q_z \,\,(1/\AA)}$', fontsize = 14)#         plt.ylabel(r'Intensity (a.u.)', fontsize = 14)#         plt.legend()#         plt.axis('tight')#         plt.show()##     if zScale == 'log':#         plt.figure('scan #{} log-scale'.format(scans))#         for s in scans:#             data = getQData(h5File, s)#             x = np.array(data['xQz'])#             y = np.array(data['yQz'])#             plt.semilogy(x, y, label = str(s))#         plt.xlabel(r'$\mathrm{q_z \,\,(1/\AA)}$', fontsize = 14)#         plt.ylabel(r'Intensity (a.u.)', fontsize = 14)#         plt.legend()#         plt.axis('tight')#         plt.show()## def plotGuiView(h5File, scanNr, zScale = 'auto', zScaling = 'lin'):#     '''View results of the q-conversion read from the .h5 file##     args#         h5File          name of the .h5 file#         scanNr          scan to plot#         zScale          z scaling, either 'auto' or give interval#         zScaling        'log' or 'lin', standard is 'lin'##     return#         plot with the different components qx, qy, qz, and the qxqz map#     '''#     import matplotlib.pyplot as plt#     from matplotlib.gridspec import GridSpec#     from pylab import cm#     from matplotlib.colors import LogNorm##     data = getQData(h5File, scanNr)##     x = np.array(data['xQz'])#     y = np.array(data['xQx'])##     I = np.sum(np.asarray(data['Intensity'][:,:]),1)#     X,Y = np.meshgrid(x,y)##     if zScale == 'auto':#         vmin = I[I > 0].min()#         vmax = I.max()#     else:#         vmin = zScale[0]#         vmax = zScale[1]##     fig = plt.figure(constrained_layout = True, figsize = (12.8, 9.6))##     gs = GridSpec(3, 3, figure = fig)##     qz = fig.add_subplot(gs[0, :-1])#     if zScaling == 'log':#         qz.semilogy(data['xQz'], data['yQz'])#     else:#         qz.plot(data['xQz'], data['yQz'])#     qz.set_xlabel(r'$q_z$ (1/$\AA$)', fontsize = 14)#     qz.set_ylabel('Intensity (a. u.)', fontsize = 14)#     qz.xaxis.set_label_position('top')#     qz.xaxis.tick_top()##     qxqz = fig.add_subplot(gs[1:, :-1])#     qxqz.set_xlabel(r'$q_z$', fontsize = 14)#     qxqz.set_ylabel(r'$q_x$', fontsize = 14)# #    ax2.imshow(I)# #    ax2.pcolormesh(X, Y, I, cmap = cm.viridis, norm = LogNorm(vmin = vmin, vmax = vmax))# #    ax2.contourf(x, y, I, cmap = cm.viridis, norm = LogNorm(vmin = vmin, vmax = vmax))#     if zScaling == 'log':#         qxqz.imshow(I, cmap = cm.viridis, norm = LogNorm(vmin = vmin, vmax = vmax), interpolation = 'bicubic', origin = 'lower', extent = (min(x), max(x), min(y), max(y)), aspect = 'auto')#     else:#         qxqz.imshow(I, cmap = cm.viridis, interpolation = 'bicubic', origin = 'lower', extent = (min(x), max(x), min(y), max(y)), aspect = 'auto')##     qx = fig.add_subplot(gs[1:, -1])#     if zScaling == 'log':#         qx.semilogx(data['yQx'], data['xQx'])#     else:#         qx.plot(data['yQx'], data['xQx'])#     qx.set_xlabel('Intensity (a. u.)', fontsize = 14)#     qx.set_ylabel(r'$q_x$ (1/$\AA$)', fontsize = 14)#     qx.xaxis.set_label_position('bottom')#     qx.xaxis.tick_bottom()#     qx.yaxis.set_label_position('right')#     qx.yaxis.tick_right()##     qy = fig.add_subplot(gs[0, 2:])#     if zScaling == 'log':#         qy.semilogy(data['xQy'], data['yQy'])#     else:#         qy.plot(data['xQy'], data['yQy'])#     qy.set_xlabel(r'$q_y$ (1/$\AA$)', fontsize = 14)#     qy.set_ylabel('Intensity (a. u.)', fontsize = 14)#     qy.xaxis.set_label_position('top')#     qy.xaxis.tick_top()#     qy.yaxis.set_label_position('right')#     qy.yaxis.tick_right()##     fig.suptitle('scan #{}'.format(scanNr), fontsize = 18)##     plt.show()## #        self.fig = Figure()# ## #        #create figure grid with subplots# #        gs = gridspec.GridSpec(2, 2,# #                               width_ratios=[3,1],# #                               height_ratios=[1,3]# #                               )# #        self.RSM_plot = self.fig.add_subplot(gs[2])# #        self.Qz_plot = self.fig.add_subplot(gs[0])# #        self.Qx_plot = self.fig.add_subplot(gs[3])# #        self.Qy_plot = self.fig.add_subplot(gs[1])# ## #        #figure widget# #        self.f = FigureCanvas(self.fig)# #        self.mainbox.pack_start(self.f, True, True, 0)# #        self.f.show()## #def absorberCorrection(energy, absober):# #    #energy, transmission = np.loadtxt('al_xray_transmission.dat', skiprows = 2, unpack = True)# #    ## #    #energyInt = np.arange(4000, 14000, 0.1)# #    ## #    #transmissionInt = np.interp(energyInt, energy, transmission)# #    ## #    ##np.savetxt('al_xray_transmission_interpolated_per3.dat', np.transpose(np.vstack((energyInt, transmissionInt))))# #    #np.savez('al_xray_transmission_interpolated_per3.npz', energy = energyInt, transmission = transmissionInt/3)# #    data = np.load('al_xray_transmission_interpolated_per3.npz')# ## #    plt.figure()# #    plt.plot(data['energy'], data['transmission'])# #    plt.plot(energy, transmission)# #    plt.show()# ## #    #plt.plot(data['energy'], data['transmission'])# ## #    # 4x30mu Al per slot -> 120 mum## def readPilatusImages(scan, PilatusFolder = 'Pilatus'):#     import xrayutilities as xu#     import matplotlib.pyplot as plt#     import numpy as np##     import glob, re## #    images = glob.glob(PilatusFolder + str('/S%0*d' % (5, scan)) + '/*' + frame + '.tif')##     pilatus = xu.io.Pilatus100K()  # initialise the Pilatus100k class from xu to read and format the images##     frames = np.zeros([121, pilatus.nop1, pilatus.nop2], dtype = np.int32)##     for frame in np.arange(0, 121):# #        print(PilatusFolder + str('/S%0*d' % (5, scan)) + '/' + 'ba19_HgTe_' + str(scan) + '_' + str(frame) + '.tif')#         image = PilatusFolder + str('/S%0*d' % (5, scan)) + '/' + 'ba19_HgTe_' + str(scan) + '_' + str(frame) + '.tif'#         frames[frame, :, :] = pilatus.readImage(image)#     frames = xpp.readPilatusDataFromh5(53, 'PilatusRaw', 'frames')#     motors = xpp.readPilatusDataFromh5(53, 'PilatusRaw', 'motors')#     data = xpp.readPilatusDataFromh5(53, '', 'data')##     return frames# #    frame = pilatus.readImage('ba19_HgTe_53_0.tif')# ## #    plt.figure()# #    plt.imshow(frame)# ### def readPilatusDataFromh5(scan, h5File, childName, dataName):#     '''#     '''#     import xrayutilities as xu##     # open the HDF5 file#     with xu.io.xu_h5open(h5File, mode = 'r') as h5:##         h5g = h5.get(list(h5.keys())[0]) # get the root##         try:#             scan = h5g.get("scan_%d" % scan) # get the current scan#             # access the child if a childName is given#             if len(childName) == 0:#                 g5 = scan#             else:#                 g5 = scan[childName]##             data =  g5[dataName][:] # get the actual dataset#         except:#             # if no data is available return False#             data = False##     return data## def getPilatusRSM(h5File, scan, grid = [23, -0.04, 0.04, 23, -0.1, 0.1, 61, 3.85, 3.96], deltas = [-1.15, 1.4, -179.64, 0.0], refPixel = [90, 220], detectorDistance = 650, energy = 'auto'):#     '''generate RSM from Pilatus scan at XPP##     args#         scan                scan number from spec file#         grid                grid for RSM: qx number of points, +/-range, qy number of points, +/-range, qz number of points, +/-range#         deltas              motor offsets: delta th, delta chi, delta phi, delta tth#         refPixel            reference pixel of direct beam at tth = 0#         detectorDistance    detector distance to the sample in mm##     returns#         dictionary containing {xQz, yQz, xQx, yQx, xQy, yQy, data}#     '''#     import xrayutilities as xu#     import numpy as np##     # initialize Pilatus detector image reader and definitions#     pilatus = xu.io.Pilatus100K()##     # get Pilatus images for scan#     frames = readPilatusDataFromh5(scan, h5File, 'PilatusRaw', 'frames')#     # get motor positions from spec file#     motors = readPilatusDataFromh5(scan, h5File, 'PilatusRaw', 'motors')#     # get scan data from spec file#     data = readPilatusDataFromh5(scan, h5File, '', 'data')#     # get energy from spec file data#     if energy == 'auto':#         energy = np.mean(data['energy'])#     else:#         energy = energy#     # init q conversion for XPP endstation & setup high-angle x-ray diffraction experiment#     qconv = xu.QConversion(('z+', 'y-', 'z+'), ('z+'), (0.0, -1.0, 0.0), en = energy)#     hxrd = xu.HXRD((1.0, 0.0, 0.0), (0.0, 0.0, 1.0), qconv = qconv, en = energy)#     # init area detector at XPP#     hxrd.Ang2Q.init_area(('z-'), ('x-'), refPixel[0], refPixel[1], pilatus.nop1, pilatus.nop2, distance = detectorDistance, pwidth1 = 0.172, pwidth2 = 0.172)#     # convert images to q#     qx, qy, qz = hxrd.Ang2Q.area(motors[0], motors[1], motors[2], motors[3], delta = (deltas[0], deltas[1], deltas[2], deltas[3]))#     # init gridder#     gridder = xu.Gridder3D(grid[0], grid[3], grid[6])#     gridder.dataRange(grid[1], grid[2], grid[4], grid[5], grid[7], grid[8])#     gridder(qx, qy, qz, frames[:,:,:])##     xQz = gridder.zaxis#     yQz = np.sum(np.sum(gridder.data, axis = 0), axis = 0)##     xQx = gridder.xaxis#     yQx = np.sum(np.sum(gridder.data, axis = 1), axis = 1)##     xQy = gridder.yaxis#     yQy = np.sum(np.sum(gridder.data, axis = 0), axis = 1)##     data = gridder.data##     return {'xQz':xQz, 'yQz':yQz, 'xQx':xQx, 'yQx':yQx, 'xQy':xQy, 'yQy':yQy, 'data':data}## def plotPilatusRSM(rsmData, plot = 'QxQz', plotStyle = 'imshow', zScale = 'auto', save = False):#     '''plot RSM#     args#         rsmData     input dictionary from getPilatusRSM output#         plot        what to plot, e.g. 'QxQz' map#         plotStyle   'imshow', 'contourf', 'pcolormesh'#         zScale      'auto' or [zMin, zMax]#     returns#         image#     '''#     import numpy as np#     import matplotlib.pyplot as plt#     from matplotlib import ticker, cm#     from matplotlib.colors import LogNorm###     x = rsmData['xQz']#     y = rsmData['xQx']#     I = np.sum(rsmData['data'], axis = 1)##     if plotStyle == 'contourf':#         plt.figure()#         plt.contourf(x, y, I, locator = ticker.LogLocator())#         plt.show()##     if plotStyle == 'imshow':#         X, Y = np.meshgrid(x,y)##         if zScale == 'auto':#             vmin = I[I > 0].min()#             vmax = I.max()#         else:#             vmin = zScale[0]#             vmax = zScale[1]##         plt.figure()#         plt.imshow(I, norm = LogNorm(vmin = vmin, vmax = vmax), origin = 'lower', extent = (x.min(), x.max(), y.min(), y.max()), interpolation = 'bicubic')#         plt.xlabel(r'$\mathrm{q_z \,\,(1/\AA)}$', fontsize = 14)#         plt.ylabel(r'$\mathrm{q_x \,\,(1/\AA)}$', fontsize = 14)#         plt.axis('tight')#         plt.show()##     if plotStyle == 'pcolormesh':#         X, Y = np.meshgrid(x,y)##         if zScale == 'auto':#             vmin = I[I > 0].min()#             vmax = I.max()#         else:#             vmin = zScale[0]#             vmax = zScale[1]##         plt.figure()#         plt.pcolormesh(X, Y, I, shading = 'nearest', norm = LogNorm(vmin = vmin, vmax = vmax))#         plt.xlabel(r'$\mathrm{q_z \,\,(1/\AA)}$', fontsize = 14)#         plt.ylabel(r'$\mathrm{q_x \,\,(1/\AA)}$', fontsize = 14)#         plt.axis('tight')#         plt.show()#### #    plt.figure()# #    plt.semilogy(gridder.zaxis, np.sum(np.sum(gridder.data, axis = 0), axis = 0))# #    plt.show()# ## #    plt.figure()# #    plt.semilogy(xQz, yQz)# #    plt.show()## #    plt.figure()# #    plt.semilogy(gridder.xaxis, np.sum(np.sum(gridder.data, axis = 1), axis = 1))# #    plt.show()## #    plt.figure()# #    plt.semilogy(gridder.yaxis, np.sum(np.sum(gridder.data, axis = 0), axis = 1))# #    plt.show()# ## #    return gridder## def plotOverview4Fit(h5Files, scans, comRange, tauOffsets):#     '''plot scans from h5 file and show ranges, for example for calculation of COM#     '''#     import numpy as np#     import matplotlib.pyplot as plt#     from udkmPy.kmc3 import xpp##     plt.figure('Pilatus measurement log-scale')#     scanData = xpp.getQData(h5Files[0], scans[0], tauOffset = tauOffsets[0])#     qValues = np.array(scanData['xQz'])#     intensity = np.array(scanData['yQz'])#     plt.semilogy(qValues, intensity, '-o', label = str(scans[0]))#     scanData = xpp.getQData(h5Files[1], scans[1], tauOffset = tauOffsets[1])#     qValues = np.array(scanData['xQz'])#     intensity = np.array(scanData['yQz'])#     plt.semilogy(qValues, intensity, '-o', label = str(scans[1]))#     plt.legend()#     plt.axvline(comRange[0], linestyle = ':', color = 'C0')#     plt.axvline(comRange[1], linestyle = ':', color = 'C0')#     plt.axvline(comRange[2], linestyle = ':', color = 'C1')#     plt.axvline(comRange[3], linestyle = ':', color = 'C1')#     plt.ylabel('Intensity', fontsize = 14)#     plt.xlabel('$q_z$ ($\AA$)', fontsize = 14)#     plt.show()##     plt.figure('Pilatus measurement lin-scale')#     scanData = xpp.getQData(h5Files[0], scans[0], tauOffset = tauOffsets[0])#     qValues = np.array(scanData['xQz'])#     intensity = np.array(scanData['yQz'])#     plt.plot(qValues, intensity, '-o', label = str(scans[0]))#     scanData = xpp.getQData(h5Files[1], scans[1], tauOffset = tauOffsets[1])#     qValues = np.array(scanData['xQz'])#     intensity = np.array(scanData['yQz'])#     plt.plot(qValues, intensity, '-o', label = str(scans[1]))#     plt.legend()#     plt.axvline(comRange[0], linestyle = ':', color = 'C0')#     plt.axvline(comRange[1], linestyle = ':', color = 'C0')#     plt.axvline(comRange[2], linestyle = ':', color = 'C1')#     plt.axvline(comRange[3], linestyle = ':', color = 'C1')#     plt.ylabel('Intensity', fontsize = 14)#     plt.xlabel('$q_z$ ($\AA$)', fontsize = 14)#     plt.show()## #def comOfRSM():## #def fitOfRSM():## def initKMC3poni(poni = 'kmc3_pilatus.poni', tth = 28):#     '''Initializes pyFAI environment for experiments at KMC3#     Keyword arguments:#         poni        path and filename of .PONI file that contains geometry information##     returns#         ai          PyFAI ai azimuthal integrator object#     '''#     import numpy as np#     import pyFAI, fabio##     # load .poni file#     ai = pyFAI.load(poni)#     ai.rot2 = np.deg2rad(tth)#     print("Prepared new integrator:\n", ai)#     return ai### def analyseData(scan, ai, analysisFolder = 'analysis', specName = 'te1', mode = 'integrate', normalize = False):#     '''Analysis function for electrical switching measurements at KMC3#     Keyword args#         scan#         ai#         specName#         mode            'integrate' -> 1d integration (standard)#                         'cake'      -> 2d integration#     '''##     import os, sys, re, glob#     import pyFAI, fabio#     import numpy as np#     from udkmPy.kmc3 import spec##     # define folder for analysed data files# #    folder = os.getcwd()#     analysisFolder = analysisFolder + '/scan' + str(scan)##     # and check whether this already exists, otherwise create it...#     try:#         os.stat(analysisFolder)#     except:#         os.mkdir(analysisFolder)##     print('Storing results in folder %s.\n' % analysisFolder)#     # prepare files for analysis#     folder = 'Pilatus/' + specName + '/S' + str('%0*d' % (5, scan))#     allImages = glob.glob(folder + '/*.tif')#     files = np.zeros(len(allImages))##     print('Loading files...\n')#     print('Sorting files...\n')##     for idx, entry in enumerate(allImages):#         fileName = os.path.basename(entry)# #        print(fileName)#         imageNumber = fileName.rstrip('.tif').split('_')[2]# #        print(imageNumber)#         files[idx] = int(imageNumber)# #    print(files)##     filesIdx = np.argsort(files)#     files = np.array(allImages)#     files = np.array(files)#     allScansSorted = files[filesIdx]##     if normalize == False:#         monitor = np.ones(len(allScansSorted))#     else:#         monitor = spec.getMonitor(specName, scan, counter = normalize)## #    print(allScansSorted)##     if mode == 'integrate':#         print('Integrating images...\n')#         for idx, entry in enumerate(allScansSorted):#             image = fabio.open(entry)#             filename = os.path.basename(entry)#             saveToFile = analysisFolder + '/' + filename.rstrip('tif') + 'int1d'#             print(saveToFile)#             int1d = ai.integrate1d(#                             image.data,#                             500,#                             unit = '2th_deg',#                             normalization_factor = monitor[idx],#                             filename = saveToFile#                           )#         print('Integration finished.\n')##     if mode == 'cake':#         print()#         print('Cake integration of all images:\n')#         print('Baking...\n')#         for idx, entry in enumerate(allScansSorted):#             image = fabio.open(entry)#             filename = os.path.basename(entry)#             saveTo = analysisFolder + '/' + filename.rstrip('.edf') + "_int2d.edf"#             print(saveTo)#             res = ai.integrate2d(image.data,#                            500, 360,#                            unit = '2th_deg',# #                           azimuth_range = (-134,-51),# #                           radial_range = (1.6,4.0),#                            normalization_factor = monitor[idx],# #                           method = 'cython',#                            filename = saveTo#                           )#             print('Saving result of image {:3}.'.format(idx + 1))#             np.savez(analysisFolder + '/' + filename.rstrip('.edf') + "_int2d", intensity = res[0], qVec = res[1], chi = res[2])#         print('\nFinished.')### def plot1dInt(scan, analysisFolder = 'analysis', comRange = [28.2, 29.7], xVector = [0]):#     '''Plot results of 1d integration'''#     import glob, os, sys, re#     import numpy as np#     import matplotlib.pyplot as plt#     import udkmPy.helper as h##     print('Sorting 1d integrated files...\n')##     allScansInt = glob.glob(analysisFolder + '/scan' + str(scan) + '/*.int1d')#     files = np.zeros(len(allScansInt))##     for idx, entry in enumerate(allScansInt):#         fileName = os.path.basename(entry)# #        print(fileName)#         fileString = fileName.split('_')[2].split('.')[0]# #        print(fileString)#         files[idx] = int(fileString)##     filesIdx = np.argsort(files)#     files = np.array(allScansInt)#     files = np.array(files)#     allScansIntSorted = files[filesIdx]#     print('All runs sorted.')##     COM = []##     plt.figure()#     for idx, entry in enumerate(allScansIntSorted):#         q, I = np.loadtxt(entry, unpack = True, skiprows = 23)#         selectRange = (q > comRange[0]) & (q < comRange[1])#         calcCOM = h.COM(q[selectRange], I[selectRange])#         COM.append(calcCOM)#         plt.plot(q, I, label = entry)# #        plt.semilogy()# #    plt.legend()#     plt.xlabel(r'2$\theta$ (deg)', fontsize = 14)#     plt.ylabel('Intensity (a.u.)', fontsize = 14)#     plt.title('1d integration of scan #{}'.format(scan), fontsize = 16)#     plt.show()##     plt.figure()#     plt.plot(xVector, COM)#     plt.xlabel('Time (ns)', fontsize = 14)#     plt.ylabel('Centre of mass', fontsize = 14)#     plt.title('1d integration of scan #{}'.format(scan), fontsize = 16)#     plt.show()### def fit1dIntAll2PV(scan, analysisFolder = 'analysis', refeed = True):#     '''Fits 2 pseudo Voigt functions to the experimental data'''#     import numpy as np#     import matplotlib.pyplot as plt#     from lmfit.models import LinearModel, PseudoVoigtModel#     import glob## #    print(out_pv.best_values)#     fitResults = {}#     dataFiles = glob.glob(analysisFolder + '/scan' + str(scan) + '/*.int1d')##     for idx, entry in enumerate(dataFiles):#         data = np.loadtxt(entry, skiprows = 23, unpack = False)##         # use loaded data, convert 2theta to q#         x = data[:,0]#         y = data[:,1]##         lin_mod = LinearModel(prefix='lin_')#         pars = lin_mod.guess(y, x = x)#         pars.update(lin_mod.make_params())#         pars['lin_intercept'].set(2, min = 0, max = 10)#         pars['lin_slope'].set(0, min = 0, vary = False)##         pv1 = PseudoVoigtModel(prefix='pv1_')#         pars.update(pv1.make_params())#         pars['pv1_center'].set(28.78, min = 28.6, max = 28.8)#         pars['pv1_sigma'].set(0.2, min = 0)#         pars['pv1_amplitude'].set(10, min = 0)#         pars['pv1_fraction'].set(0, min = 0, max = 1)##         pv2 = PseudoVoigtModel(prefix='pv2_')#         pars.update(pv2.make_params())#         pars['pv2_center'].set(29.1, min = 28.8, max = 29.2)#         pars['pv2_sigma'].set(0.1, min = 0)#         pars['pv2_amplitude'].set(1, min = 0)#         pars['pv2_fraction'].set(0, min = 0, max = 1)##         mod_pv = pv1 + pv2 + lin_mod##         init_pv = mod_pv.eval(pars, x = x)#         out_pv = mod_pv.fit(y, pars, x = x)##         print(out_pv.fit_report(min_correl = 0.5))##         plt.figure()##         plt.plot(x, y, 'bo')#         plt.plot(x, init_pv, 'k--')#         plt.plot(x, out_pv.best_fit, 'r-')##         comps = out_pv.eval_components(x = x)#         plt.plot(x, comps['pv1_'], '--')#         plt.plot(x, comps['pv2_'], '--')#         plt.plot(x, comps['lin_'], '--')##         plt.show()#         fitResults[idx] = out_pv##         print('Finished fitting %4i scans.' % (idx+1))##     return fitResults